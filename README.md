# flask-skeleton

A skeleton project for flask.

## 代码分层

将代码根据特定的规则（按功能划分，或者按职责划分）分层，有利于降低模块之间的耦合度，提高代码可维护性和可扩展性。

### module（模块）

此目录包含本项目的核心处理逻辑。一个模块应该至少包含 controller、manager、parser、service 子模块（后面会分别介绍这些子模块是干啥的）。值得注意的是，我这里是根据功能划分了核心处理逻辑，除了根据功能，也可以根据职责划分，比如将处理逻辑分为 controller、manager、service 等大模块，然后每个大模块里再分别包含不同领域的业务模型。选择那种划分方式完全取决于实际项目，并不是万古不变的，且各有利弊（此处不多讨论）。

#### service 子模块

该模块包含某个领域的所有业务逻辑，通常会语一个 model 绑定，该模块的所有业务逻辑均围绕这一个 model，且业务逻辑都是原子业务，不可再分。

需要注意的是，我这里默认会使用ORM对数据进行持久化处理，倘若不使用ORM而直接使用例如SQL语句进行持久化，那需要考虑再增加一个DAO层，实现对数据连接层的隔离。

#### manager 子模块

有时候一个业务是由多个不同领域的业务组合调用才能实现的，这种情况下如果任由 service 模块之间调用，就非常容易出现循环引用的问题，并且大大增加了模块之间的耦合度和复杂性，非常不利于维护。为了解决这个问题引入了 manager 层，manager 里的业务可以是原子业务，也可以是复合业务，他可以依赖一个或多个不同领域的业务。一个复合业务的实现通常是各种原子业务的组合调用，而不应该直接把实际的业务逻辑写到 manager 里面去，如果打算再 manager 里写业务，那就要考虑一下这些代码是否可以放到对应的 service 里。

#### parser 子模块

这个模块可以封装客户端发来请求的数据解析方式，比如query string、body、form、file等等。

封装这一层的好处是，我可以把参数校验放到这里，这样可以直接在解析请求数据的时候拒绝掉格式不正确的请求，避免其流入到业务逻辑层。另外，这一层可以让业务逻辑层真正与框架无关，无论是使用Django还是Flask，解析完以后的数据都是固定的。

#### controller 子模块

该模块包含改领域业务下的所有控制器类，控制器类的实例化依赖一个 manager 类。用于接收用户请求并分配到合适的 manager 类的业务。

这一层通常与你使用的框架关联较密切，比如你使用flask-restful，就可以在这一层定义一堆Resource（继承flask-restful提供的Resource基类）。

### common（公共）

此目录下的模块相当于 global bus，用于存放供其他所有模块调用的代码例如各种基类、结构体、常量、配置等，一些需要统一调度的东西如统一异常处理、路由定义、资源初始化等等也放到这个目录下。

该层也可以有效避免模块循环调用的问题。

#### exceptions 子模块

这里包含异常基类的定义，以及统一异常处理。

#### routes 子模块

包含路由的定义。

### helper（助手）

此目录下存放各种外部服务调用的模块，相当于防腐层。当你需要调用外部服务时，可以为该外部服务提供一个 helper，这样可以有效降低外部服务对你的内部服务的影响（比如设置各种失败处理），同时也有利于单元测试（把 helper mock 掉）。

